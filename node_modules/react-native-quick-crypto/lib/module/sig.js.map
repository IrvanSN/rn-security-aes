{"version":3,"sources":["sig.ts"],"names":["NativeQuickCrypto","Stream","DSASigEnc","binaryLikeToArrayBuffer","getDefaultEncoding","preparePrivateKey","preparePublicOrPrivateKey","createInternalSign","createSign","createInternalVerify","createVerify","getPadding","options","getIntOption","getSaltLength","getDSASignatureEncoding","dsaEncoding","kSigEncDER","kSigEncP1363","Error","name","value","undefined","Verify","Writable","constructor","algorithm","internal","init","_write","chunk","encoding","callback","update","data","verify","signature","format","type","passphrase","rsaPadding","pssSaltLength","dsaSigEnc","ret","Sign","sign","Buffer","from","toString"],"mappings":"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","sourcesContent":["import { NativeQuickCrypto } from './NativeQuickCrypto/NativeQuickCrypto';\nimport type { InternalSign, InternalVerify } from './NativeQuickCrypto/sig';\nimport Stream from 'stream-browserify';\n\n// TODO(osp) same as publicCipher on node this are defined on C++ and exposed to node\n// Do the same here\nenum DSASigEnc {\n  kSigEncDER,\n  kSigEncP1363,\n}\n\nimport {\n  BinaryLike,\n  binaryLikeToArrayBuffer,\n  getDefaultEncoding,\n} from './Utils';\nimport { preparePrivateKey, preparePublicOrPrivateKey } from './keys';\n\nconst createInternalSign = NativeQuickCrypto.createSign;\nconst createInternalVerify = NativeQuickCrypto.createVerify;\n\nfunction getPadding(options: any) {\n  return getIntOption('padding', options);\n}\n\nfunction getSaltLength(options: any) {\n  return getIntOption('saltLength', options);\n}\n\nfunction getDSASignatureEncoding(options: any) {\n  if (typeof options === 'object') {\n    const { dsaEncoding = 'der' } = options;\n    if (dsaEncoding === 'der') return DSASigEnc.kSigEncDER;\n    else if (dsaEncoding === 'ieee-p1363') return DSASigEnc.kSigEncP1363;\n    throw new Error(`options.dsaEncoding: ${dsaEncoding} not a valid encoding`);\n  }\n\n  return DSASigEnc.kSigEncDER;\n}\n\nfunction getIntOption(name: string, options: any) {\n  const value = options[name];\n  if (value !== undefined) {\n    if (value === value >> 0) {\n      return value;\n    }\n    throw new Error(`options.${name}: ${value} not a valid int value`);\n  }\n  return undefined;\n}\n\nclass Verify extends Stream.Writable {\n  private internal: InternalVerify;\n  constructor(algorithm: string, options: Stream.WritableOptions) {\n    super(options);\n    this.internal = createInternalVerify();\n    this.internal.init(algorithm);\n  }\n\n  _write(chunk: BinaryLike, encoding: string, callback: () => void) {\n    this.update(chunk, encoding);\n    callback();\n  }\n\n  update(data: BinaryLike, encoding?: string) {\n    encoding = encoding ?? getDefaultEncoding();\n    data = binaryLikeToArrayBuffer(data, encoding);\n    this.internal.update(data);\n    return this;\n  }\n\n  verify(\n    options: {\n      key: string | Buffer;\n      format?: string;\n      type?: string;\n      passphrase?: string;\n      padding?: number;\n      saltLength?: number;\n    },\n    signature: BinaryLike\n  ): boolean {\n    if (!options) {\n      throw new Error('Crypto sign key required');\n    }\n\n    const { data, format, type, passphrase } =\n      preparePublicOrPrivateKey(options);\n\n    const rsaPadding = getPadding(options);\n    const pssSaltLength = getSaltLength(options);\n\n    // Options specific to (EC)DSA\n    const dsaSigEnc = getDSASignatureEncoding(options);\n\n    const ret = this.internal.verify(\n      data,\n      format,\n      type,\n      passphrase,\n      binaryLikeToArrayBuffer(signature),\n      rsaPadding,\n      pssSaltLength,\n      dsaSigEnc\n    );\n\n    return ret;\n  }\n}\n\nclass Sign extends Stream.Writable {\n  private internal: InternalSign;\n  constructor(algorithm: string, options: Stream.WritableOptions) {\n    super(options);\n    this.internal = createInternalSign();\n    this.internal.init(algorithm);\n  }\n\n  _write(chunk: BinaryLike, encoding: string, callback: () => void) {\n    this.update(chunk, encoding);\n    callback();\n  }\n\n  update(data: BinaryLike, encoding?: string) {\n    encoding = encoding ?? getDefaultEncoding();\n    data = binaryLikeToArrayBuffer(data, encoding);\n    this.internal.update(data);\n    return this;\n  }\n\n  sign(\n    options: {\n      key: string | Buffer;\n      format?: string;\n      type?: string;\n      passphrase?: string;\n      padding?: number;\n      saltLength?: number;\n    },\n    encoding?: string\n  ) {\n    if (!options) {\n      throw new Error('Crypto sign key required');\n    }\n\n    const { data, format, type, passphrase } = preparePrivateKey(options);\n\n    const rsaPadding = getPadding(options);\n    const pssSaltLength = getSaltLength(options);\n\n    // Options specific to (EC)DSA\n    const dsaSigEnc = getDSASignatureEncoding(options);\n\n    const ret = this.internal.sign(\n      data,\n      format,\n      type,\n      passphrase,\n      rsaPadding,\n      pssSaltLength,\n      dsaSigEnc\n    );\n\n    encoding = encoding || getDefaultEncoding();\n    if (encoding && encoding !== 'buffer') {\n      return Buffer.from(ret).toString(encoding as any);\n    }\n\n    return Buffer.from(ret);\n  }\n}\n\nexport function createSign(algorithm: string, options?: any) {\n  return new Sign(algorithm, options);\n}\n\nexport function createVerify(algorithm: string, options?: any) {\n  return new Verify(algorithm, options);\n}\n"]}