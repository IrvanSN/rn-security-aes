{"version":3,"sources":["Hash.ts"],"names":["NativeQuickCrypto","toArrayBuffer","Stream","Buffer","global","process","nextTick","setImmediate","createInternalHash","createHash","algorithm","options","Hash","Transform","constructor","arg","undefined","internalHash","copy","outputLength","update","data","inputEncoding","ArrayBuffer","buffer","from","_transform","chunk","encoding","callback","_flush","push","digest","result","toString"],"mappings":";;AAAA;AACA,OAAO,cAAP;AACA,SAASA,iBAAT,QAAkC,uCAAlC;AAEA,SAAmBC,aAAnB,QAAwC,SAAxC;AACA,OAAOC,MAAP,MAAmB,mBAAnB;AACA,SAASC,MAAT,QAAuB,gCAAvB;AAOAC,MAAM,CAACC,OAAP,CAAeC,QAAf,GAA0BC,YAA1B;AAEA,MAAMC,kBAAkB,GAAGR,iBAAiB,CAACS,UAA7C;AAIA,OAAO,SAASA,UAAT,CAAoBC,SAApB,EAAuCC,OAAvC,EAA8D;AACnE,SAAO,IAAIC,IAAJ,CAASF,SAAT,EAAoBC,OAApB,CAAP;AACD;;AAED,MAAMC,IAAN,SAAmBV,MAAM,CAACW,SAA1B,CAAoC;AAKlCC,EAAAA,WAAW,CAACC,GAAD,EAAqBJ,OAArB,EAA4C;AACrD,UAAMA,OAAN,aAAMA,OAAN,cAAMA,OAAN,GAAiBK,SAAjB;;AADqD;;AAErD,QAAID,GAAG,YAAYH,IAAnB,EAAyB;AACvB,WAAKK,YAAL,GAAoBF,GAAG,CAACE,YAAJ,CAAiBC,IAAjB,CAAsBP,OAAtB,aAAsBA,OAAtB,uBAAsBA,OAAO,CAAEQ,YAA/B,CAApB;AACD,KAFD,MAEO;AACL,WAAKF,YAAL,GAAoBT,kBAAkB,CAACO,GAAD,EAAMJ,OAAN,aAAMA,OAAN,uBAAMA,OAAO,CAAEQ,YAAf,CAAtC;AACD;AACF;;AAEDD,EAAAA,IAAI,CAACP,OAAD,EAAkC;AACpC,UAAMO,IAAI,GAAG,IAAIN,IAAJ,CAAS,IAAT,EAAeD,OAAf,CAAb;AACA,WAAOO,IAAP;AACD;AACD;AACF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AACEE,EAAAA,MAAM,CAACC,IAAD,EAA4BC,aAA5B,EAA4D;AAChE,QAAID,IAAI,YAAYE,WAApB,EAAiC;AAC/B,WAAKN,YAAL,CAAkBG,MAAlB,CAAyBC,IAAzB;AACA,aAAO,IAAP;AACD;;AACD,UAAMG,MAAM,GAAGrB,MAAM,CAACsB,IAAP,CAAYJ,IAAZ,EAAkBC,aAAlB,CAAf;AACA,SAAKL,YAAL,CAAkBG,MAAlB,CAAyBnB,aAAa,CAACuB,MAAD,CAAtC;AACA,WAAO,IAAP;AACD;;AAEDE,EAAAA,UAAU,CACRC,KADQ,EAERC,QAFQ,EAGRC,QAHQ,EAIR;AACA,SAAKT,MAAL,CAAYO,KAAZ,EAAmBC,QAAnB;AACAC,IAAAA,QAAQ;AACT;;AAEDC,EAAAA,MAAM,CAACD,QAAD,EAAuB;AAC3B,SAAKE,IAAL,CAAU,KAAKC,MAAL,EAAV;AACAH,IAAAA,QAAQ;AACT;AAED;AACF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AAIEG,EAAAA,MAAM,CAACJ,QAAD,EAAkD;AACtD,UAAMK,MAAmB,GAAG,KAAKhB,YAAL,CAAkBe,MAAlB,EAA5B;;AAEA,QAAIJ,QAAQ,IAAIA,QAAQ,KAAK,QAA7B,EAAuC;AACrC,aAAOzB,MAAM,CAACsB,IAAP,CAAYQ,MAAZ,EAAoBC,QAApB,CAA6BN,QAA7B,CAAP;AACD;;AAED,WAAOzB,MAAM,CAACsB,IAAP,CAAYQ,MAAZ,CAAP;AACD;;AAzEiC","sourcesContent":["/* eslint-disable no-dupe-class-members */\nimport 'react-native';\nimport { NativeQuickCrypto } from './NativeQuickCrypto/NativeQuickCrypto';\nimport type { InternalHash } from './NativeQuickCrypto/hash';\nimport { Encoding, toArrayBuffer } from './Utils';\nimport Stream from 'stream-browserify';\nimport { Buffer } from '@craftzdog/react-native-buffer';\ninterface HashOptionsBase extends Stream.TransformOptions {\n  outputLength?: number | undefined;\n}\n\ntype HashOptions = null | undefined | HashOptionsBase;\n\nglobal.process.nextTick = setImmediate;\n\nconst createInternalHash = NativeQuickCrypto.createHash;\n\ntype BinaryLike = ArrayBuffer;\n\nexport function createHash(algorithm: string, options?: HashOptions) {\n  return new Hash(algorithm, options);\n}\n\nclass Hash extends Stream.Transform {\n  private internalHash: InternalHash;\n\n  constructor(other: Hash, options?: HashOptions);\n  constructor(algorithm: string, options?: HashOptions);\n  constructor(arg: string | Hash, options?: HashOptions) {\n    super(options ?? undefined);\n    if (arg instanceof Hash) {\n      this.internalHash = arg.internalHash.copy(options?.outputLength);\n    } else {\n      this.internalHash = createInternalHash(arg, options?.outputLength);\n    }\n  }\n\n  copy(options?: HashOptionsBase): Hash {\n    const copy = new Hash(this, options);\n    return copy;\n  }\n  /**\n   * Updates the hash content with the given `data`, the encoding of which\n   * is given in `inputEncoding`.\n   * If `encoding` is not provided, and the `data` is a string, an\n   * encoding of `'utf8'` is enforced. If `data` is a `Buffer`, `TypedArray`, or`DataView`, then `inputEncoding` is ignored.\n   *\n   * This can be called many times with new data as it is streamed.\n   * @since v0.1.92\n   * @param inputEncoding The `encoding` of the `data` string.\n   */\n  update(data: string | BinaryLike, inputEncoding?: Encoding): Hash {\n    if (data instanceof ArrayBuffer) {\n      this.internalHash.update(data);\n      return this;\n    }\n    const buffer = Buffer.from(data, inputEncoding);\n    this.internalHash.update(toArrayBuffer(buffer));\n    return this;\n  }\n\n  _transform(\n    chunk: string | BinaryLike,\n    encoding: Encoding,\n    callback: () => void\n  ) {\n    this.update(chunk, encoding);\n    callback();\n  }\n\n  _flush(callback: () => void) {\n    this.push(this.digest());\n    callback();\n  }\n\n  /**\n   * Calculates the digest of all of the data passed to be hashed (using the `hash.update()` method).\n   * If `encoding` is provided a string will be returned; otherwise\n   * a `Buffer` is returned.\n   *\n   * The `Hash` object can not be used again after `hash.digest()` method has been\n   * called. Multiple calls will cause an error to be thrown.\n   * @since v0.1.92\n   * @param encoding The `encoding` of the return value.\n   */\n  digest(): Buffer;\n  digest(encoding: 'buffer'): Buffer;\n  digest(encoding: Encoding): string;\n  digest(encoding?: Encoding | 'buffer'): string | Buffer {\n    const result: ArrayBuffer = this.internalHash.digest();\n\n    if (encoding && encoding !== 'buffer') {\n      return Buffer.from(result).toString(encoding);\n    }\n\n    return Buffer.from(result);\n  }\n}\n"]}