/// <reference types="node" />
/// <reference types="node" />
/// <reference types="node" />
import { Buffer } from '@craftzdog/react-native-buffer';
import FallbackCrypto from 'crypto-browserify';
declare const crypto: {
    randomFill<T extends Buffer | ArrayBufferLike | (Uint8Array | Uint8ClampedArray | Uint16Array | Uint32Array | Int8Array | Int16Array | Int32Array | Float32Array | Float64Array) | DataView>(buffer: T, callback: (err: Error | null, buf: T) => void): void;
    randomFill<T_1 extends Buffer | ArrayBufferLike | (Uint8Array | Uint8ClampedArray | Uint16Array | Uint32Array | Int8Array | Int16Array | Int32Array | Float32Array | Float64Array) | DataView>(buffer: T_1, offset: number, callback: (err: Error | null, buf: T_1) => void): void;
    randomFill<T_2 extends Buffer | ArrayBufferLike | (Uint8Array | Uint8ClampedArray | Uint16Array | Uint32Array | Int8Array | Int16Array | Int32Array | Float32Array | Float64Array) | DataView>(buffer: T_2, offset: number, size: number, callback: (err: Error | null, buf: T_2) => void): void;
    randomFillSync<T_3 extends Buffer | ArrayBufferLike | (Uint8Array | Uint8ClampedArray | Uint16Array | Uint32Array | Int8Array | Int16Array | Int32Array | Float32Array | Float64Array) | DataView>(buffer: T_3, offset?: number | undefined, size?: number | undefined): T_3;
    randomBytes(size: number): ArrayBuffer;
    randomBytes(size: number, callback: (err: Error | null, buf?: ArrayBuffer | undefined) => void): void;
    randomInt(max: number, callback: (err: Error | null, value: number) => void): void;
    randomInt(max: number): number;
    randomInt(min: number, max: number, callback: (err: Error | null, value: number) => void): void;
    randomInt(min: number, max: number): number;
    getRandomValues(data: Uint8Array | Uint16Array | Uint32Array | Int8Array | Int16Array | Int32Array): Uint8Array | Uint16Array | Uint32Array | Int8Array | Int16Array | Int32Array;
    randomUUID(): string;
    rng: typeof import("./random").randomBytes;
    pseudoRandomBytes: typeof import("./random").randomBytes;
    prng: typeof import("./random").randomBytes;
    pbkdf2(password: import("./Utils").BinaryLike, salt: import("./Utils").BinaryLike, iterations: number, keylen: number, digest: string, callback: (err: Error | null, derivedKey?: Buffer | undefined) => void): void;
    pbkdf2(password: import("./Utils").BinaryLike, salt: import("./Utils").BinaryLike, iterations: number, keylen: number, callback: (err: Error | null, derivedKey?: Buffer | undefined) => void): void;
    pbkdf2Sync(password: import("./Utils").BinaryLike, salt: import("./Utils").BinaryLike, iterations: number, keylen: number, digest?: string | undefined): Buffer;
    createHmac: typeof import("./Hmac").createHmac;
    Hmac: typeof import("./Hmac").createHmac;
    Hash: typeof import("./Hash").createHash;
    createHash: typeof import("./Hash").createHash;
    createCipher: typeof import("./Cipher").createCipher;
    createCipheriv: typeof import("./Cipher").createCipheriv;
    createDecipher: typeof import("./Cipher").createDecipher;
    createDecipheriv: typeof import("./Cipher").createDecipheriv;
    publicEncrypt: (options: {
        key: any;
        encoding?: string | undefined;
        format?: any;
        padding?: any;
        oaepHash?: any;
        oaepLabel?: any;
        passphrase?: string | undefined;
    }, buffer: import("./Utils").BinaryLike) => Buffer;
    publicDecrypt: (options: {
        key: any;
        encoding?: string | undefined;
        format?: any;
        padding?: any;
        oaepHash?: any;
        oaepLabel?: any;
        passphrase?: string | undefined;
    }, buffer: import("./Utils").BinaryLike) => Buffer;
    privateDecrypt: (options: {
        key: any;
        encoding?: string | undefined;
        format?: any;
        padding?: any;
        oaepHash?: any;
        oaepLabel?: any;
        passphrase?: string | undefined;
    }, buffer: import("./Utils").BinaryLike) => Buffer;
    generateKeyPair: typeof import("./Cipher").generateKeyPair;
    generateKeyPairSync: typeof import("./Cipher").generateKeyPairSync;
    createSign: typeof import("./sig").createSign;
    createVerify: typeof import("./sig").createVerify;
    constants: {
        OPENSSL_VERSION_NUMBER: number;
        SSL_OP_ALL: number;
        SSL_OP_ALLOW_NO_DHE_KEX: number;
        SSL_OP_ALLOW_UNSAFE_LEGACY_RENEGOTIATION: number;
        SSL_OP_CIPHER_SERVER_PREFERENCE: number;
        SSL_OP_CISCO_ANYCONNECT: number;
        SSL_OP_COOKIE_EXCHANGE: number;
        SSL_OP_CRYPTOPRO_TLSEXT_BUG: number;
        SSL_OP_DONT_INSERT_EMPTY_FRAGMENTS: number;
        SSL_OP_EPHEMERAL_RSA: number;
        SSL_OP_LEGACY_SERVER_CONNECT: number;
        SSL_OP_MICROSOFT_BIG_SSLV3_BUFFER: number;
        SSL_OP_MICROSOFT_SESS_ID_BUG: number;
        SSL_OP_MSIE_SSLV2_RSA_PADDING: number;
        SSL_OP_NETSCAPE_CA_DN_BUG: number;
        SSL_OP_NETSCAPE_CHALLENGE_BUG: number;
        SSL_OP_NETSCAPE_DEMO_CIPHER_CHANGE_BUG: number;
        SSL_OP_NETSCAPE_REUSE_CIPHER_CHANGE_BUG: number;
        SSL_OP_NO_COMPRESSION: number;
        SSL_OP_NO_ENCRYPT_THEN_MAC: number;
        SSL_OP_NO_QUERY_MTU: number;
        SSL_OP_NO_RENEGOTIATION: number;
        SSL_OP_NO_SESSION_RESUMPTION_ON_RENEGOTIATION: number;
        SSL_OP_NO_SSLv2: number;
        SSL_OP_NO_SSLv3: number;
        SSL_OP_NO_TICKET: number;
        SSL_OP_NO_TLSv1: number;
        SSL_OP_NO_TLSv1_1: number;
        SSL_OP_NO_TLSv1_2: number;
        SSL_OP_NO_TLSv1_3: number;
        SSL_OP_PKCS1_CHECK_1: number;
        SSL_OP_PKCS1_CHECK_2: number;
        SSL_OP_PRIORITIZE_CHACHA: number;
        SSL_OP_SINGLE_DH_USE: number;
        SSL_OP_SINGLE_ECDH_USE: number;
        SSL_OP_SSLEAY_080_CLIENT_DH_BUG: number;
        SSL_OP_SSLREF2_REUSE_CERT_TYPE_BUG: number;
        SSL_OP_TLS_BLOCK_PADDING_BUG: number;
        SSL_OP_TLS_D5_BUG: number;
        SSL_OP_TLS_ROLLBACK_BUG: number;
        ENGINE_METHOD_RSA: number;
        ENGINE_METHOD_DSA: number;
        ENGINE_METHOD_DH: number;
        ENGINE_METHOD_RAND: number;
        ENGINE_METHOD_EC: number;
        ENGINE_METHOD_CIPHERS: number;
        ENGINE_METHOD_DIGESTS: number;
        ENGINE_METHOD_PKEY_METHS: number;
        ENGINE_METHOD_PKEY_ASN1_METHS: number;
        ENGINE_METHOD_ALL: number;
        ENGINE_METHOD_NONE: number;
        DH_CHECK_P_NOT_SAFE_PRIME: number;
        DH_CHECK_P_NOT_PRIME: number;
        DH_UNABLE_TO_CHECK_GENERATOR: number;
        DH_NOT_SUITABLE_GENERATOR: number;
        ALPN_ENABLED: number;
        RSA_PKCS1_PADDING: number;
        RSA_SSLV23_PADDING: number;
        RSA_NO_PADDING: number;
        RSA_PKCS1_OAEP_PADDING: number;
        RSA_X931_PADDING: number;
        RSA_PKCS1_PSS_PADDING: number;
        RSA_PSS_SALTLEN_DIGEST: number;
        RSA_PSS_SALTLEN_MAX_SIGN: number;
        RSA_PSS_SALTLEN_AUTO: number;
        defaultCoreCipherList: string;
        TLS1_VERSION: number;
        TLS1_1_VERSION: number;
        TLS1_2_VERSION: number;
        TLS1_3_VERSION: number;
        POINT_CONVERSION_COMPRESSED: number;
        POINT_CONVERSION_UNCOMPRESSED: number;
        POINT_CONVERSION_HYBRID: number;
    };
    generateKey(type: "hmac" | "aes", options: {
        length: number;
    }, callback: (err: Error | null, key: FallbackCrypto.KeyObject) => void): void;
    generateKeySync(type: "hmac" | "aes", options: {
        length: number;
    }): FallbackCrypto.KeyObject;
    createPrivateKey(key: string | globalThis.Buffer | FallbackCrypto.PrivateKeyInput | FallbackCrypto.JsonWebKeyInput): FallbackCrypto.KeyObject;
    createPublicKey(key: string | globalThis.Buffer | FallbackCrypto.KeyObject | FallbackCrypto.JsonWebKeyInput | FallbackCrypto.PublicKeyInput): FallbackCrypto.KeyObject;
    createSecretKey(key: NodeJS.ArrayBufferView): FallbackCrypto.KeyObject;
    createSecretKey(key: string, encoding: BufferEncoding): FallbackCrypto.KeyObject;
    createDiffieHellman(primeLength: number, generator?: number | NodeJS.ArrayBufferView | undefined): FallbackCrypto.DiffieHellman;
    createDiffieHellman(prime: NodeJS.ArrayBufferView): FallbackCrypto.DiffieHellman;
    createDiffieHellman(prime: string, primeEncoding: FallbackCrypto.BinaryToTextEncoding): FallbackCrypto.DiffieHellman;
    createDiffieHellman(prime: string, primeEncoding: FallbackCrypto.BinaryToTextEncoding, generator: number | NodeJS.ArrayBufferView): FallbackCrypto.DiffieHellman;
    createDiffieHellman(prime: string, primeEncoding: FallbackCrypto.BinaryToTextEncoding, generator: string, generatorEncoding: FallbackCrypto.BinaryToTextEncoding): FallbackCrypto.DiffieHellman;
    getDiffieHellman(groupName: string): FallbackCrypto.DiffieHellman;
    scrypt(password: FallbackCrypto.BinaryLike, salt: FallbackCrypto.BinaryLike, keylen: number, callback: (err: Error | null, derivedKey: globalThis.Buffer) => void): void;
    scrypt(password: FallbackCrypto.BinaryLike, salt: FallbackCrypto.BinaryLike, keylen: number, options: FallbackCrypto.ScryptOptions, callback: (err: Error | null, derivedKey: globalThis.Buffer) => void): void;
    scryptSync(password: FallbackCrypto.BinaryLike, salt: FallbackCrypto.BinaryLike, keylen: number, options?: FallbackCrypto.ScryptOptions | undefined): globalThis.Buffer;
    privateEncrypt(privateKey: FallbackCrypto.RsaPrivateKey | FallbackCrypto.KeyLike, buffer: NodeJS.ArrayBufferView): globalThis.Buffer;
    getCiphers(): string[];
    getCurves(): string[];
    getFips(): 0 | 1;
    getHashes(): string[];
    createECDH(curveName: string): FallbackCrypto.ECDH;
    timingSafeEqual(a: NodeJS.ArrayBufferView, b: NodeJS.ArrayBufferView): boolean;
    sign(algorithm: string | null | undefined, data: NodeJS.ArrayBufferView, key: FallbackCrypto.KeyLike | FallbackCrypto.SignKeyObjectInput | FallbackCrypto.SignPrivateKeyInput): globalThis.Buffer;
    sign(algorithm: string | null | undefined, data: NodeJS.ArrayBufferView, key: FallbackCrypto.KeyLike | FallbackCrypto.SignKeyObjectInput | FallbackCrypto.SignPrivateKeyInput, callback: (error: Error | null, data: globalThis.Buffer) => void): void;
    verify(algorithm: string | null | undefined, data: NodeJS.ArrayBufferView, key: FallbackCrypto.KeyLike | FallbackCrypto.VerifyKeyObjectInput | FallbackCrypto.VerifyPublicKeyInput, signature: NodeJS.ArrayBufferView): boolean;
    verify(algorithm: string | null | undefined, data: NodeJS.ArrayBufferView, key: FallbackCrypto.KeyLike | FallbackCrypto.VerifyKeyObjectInput | FallbackCrypto.VerifyPublicKeyInput, signature: NodeJS.ArrayBufferView, callback: (error: Error | null, result: boolean) => void): void;
    diffieHellman(options: {
        privateKey: FallbackCrypto.KeyObject;
        publicKey: FallbackCrypto.KeyObject;
    }): globalThis.Buffer;
    getCipherInfo(nameOrNid: string | number, options?: FallbackCrypto.CipherInfoOptions | undefined): FallbackCrypto.CipherInfo | undefined;
    hkdf(digest: string, irm: FallbackCrypto.KeyObject | FallbackCrypto.BinaryLike, salt: FallbackCrypto.BinaryLike, info: FallbackCrypto.BinaryLike, keylen: number, callback: (err: Error | null, derivedKey: ArrayBuffer) => void): void;
    hkdfSync(digest: string, ikm: FallbackCrypto.KeyObject | FallbackCrypto.BinaryLike, salt: FallbackCrypto.BinaryLike, info: FallbackCrypto.BinaryLike, keylen: number): ArrayBuffer;
    secureHeapUsed(): FallbackCrypto.SecureHeapUsage;
    generatePrime(size: number, callback: (err: Error | null, prime: ArrayBuffer) => void): void;
    generatePrime(size: number, options: FallbackCrypto.GeneratePrimeOptionsBigInt, callback: (err: Error | null, prime: bigint) => void): void;
    generatePrime(size: number, options: FallbackCrypto.GeneratePrimeOptionsArrayBuffer, callback: (err: Error | null, prime: ArrayBuffer) => void): void;
    generatePrime(size: number, options: FallbackCrypto.GeneratePrimeOptions, callback: (err: Error | null, prime: bigint | ArrayBuffer) => void): void;
    generatePrimeSync(size: number): ArrayBuffer;
    generatePrimeSync(size: number, options: FallbackCrypto.GeneratePrimeOptionsBigInt): bigint;
    generatePrimeSync(size: number, options: FallbackCrypto.GeneratePrimeOptionsArrayBuffer): ArrayBuffer;
    generatePrimeSync(size: number, options: FallbackCrypto.GeneratePrimeOptions): bigint | ArrayBuffer;
    checkPrime(value: FallbackCrypto.LargeNumberLike, callback: (err: Error | null, result: boolean) => void): void;
    checkPrime(value: FallbackCrypto.LargeNumberLike, options: FallbackCrypto.CheckPrimeOptions, callback: (err: Error | null, result: boolean) => void): void;
    checkPrimeSync(candidate: FallbackCrypto.LargeNumberLike, options?: FallbackCrypto.CheckPrimeOptions | undefined): boolean;
    Certificate: FallbackCrypto.Certificate & {
        (): FallbackCrypto.Certificate;
        new (): FallbackCrypto.Certificate;
        exportChallenge(spkac: FallbackCrypto.BinaryLike): globalThis.Buffer;
        exportPublicKey(spkac: FallbackCrypto.BinaryLike, encoding?: string | undefined): globalThis.Buffer;
        verifySpkac(spkac: NodeJS.ArrayBufferView): boolean;
    };
    fips: boolean;
    KeyObject: typeof FallbackCrypto.KeyObject;
    Cipher: typeof FallbackCrypto.Cipher;
    Decipher: typeof FallbackCrypto.Decipher;
    Sign: typeof FallbackCrypto.Sign;
    Verify: typeof FallbackCrypto.Verify;
    DiffieHellman: typeof FallbackCrypto.DiffieHellman;
    ECDH: typeof FallbackCrypto.ECDH;
    DEFAULT_ENCODING: BufferEncoding;
    X509Certificate: typeof FallbackCrypto.X509Certificate;
    webcrypto: typeof FallbackCrypto.webcrypto;
};
export default crypto;
