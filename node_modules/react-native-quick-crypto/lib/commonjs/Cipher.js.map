{"version":3,"sources":["Cipher.ts"],"names":["global","process","nextTick","setImmediate","createInternalCipher","NativeQuickCrypto","createCipher","createInternalDecipher","createDecipher","_publicEncrypt","publicEncrypt","_publicDecrypt","publicDecrypt","_privateDecrypt","privateDecrypt","getUIntOption","options","key","value","Error","normalizeEncoding","enc","retried","toLowerCase","validateEncoding","data","encoding","normalizedEncoding","length","getDecoder","decoder","StringDecoder","CipherCommon","Stream","Transform","constructor","cipherType","cipherKey","isCipher","iv","cipherKeyBuffer","authTagLength","args","cipher_type","cipher_key","auth_tag_len","internal","update","inputEncoding","outputEncoding","defaultEncoding","ArrayBuffer","isView","ret","write","SBuffer","from","final","end","_transform","chunk","callback","push","_flush","setAutoPadding","autoPadding","setAAD","buffer","plaintextLength","setAuthTag","tag","Cipher","Decipher","algorithm","password","createDecipheriv","createCipheriv","rsaFunctionFor","method","defaultPadding","keyType","format","type","passphrase","padding","oaepHash","oaepLabel","undefined","rawRes","Buffer","constants","RSA_PKCS1_OAEP_PADDING","RSA_PKCS1_PADDING","parseKeyEncoding","kEmptyObject","publicKeyEncoding","privateKeyEncoding","publicFormat","publicType","privateFormat","privateType","cipher","internalGenerateKeyPair","isAsync","modulusLength","publicExponent","generateKeyPair","RSAKeyVariant","kKeyVariantRSA_SSA_PKCS1_v1_5","then","err","publicKey","privateKey","catch","generateKeyPairSync","hash","mgf1Hash","hashAlgorithm","mgf1HashAlgorithm","saltLength","kKeyVariantRSA_PSS","_"],"mappings":"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","sourcesContent":["/* eslint-disable no-dupe-class-members */\nimport { NativeQuickCrypto } from './NativeQuickCrypto/NativeQuickCrypto';\nimport Stream from 'stream-browserify';\nimport {\n  BinaryLike,\n  binaryLikeToArrayBuffer,\n  CipherEncoding,\n  Encoding,\n  getDefaultEncoding,\n  kEmptyObject,\n  validateFunction,\n  validateObject,\n  validateString,\n  validateUint32,\n  validateInt32,\n} from './Utils';\nimport { InternalCipher, RSAKeyVariant } from './NativeQuickCrypto/Cipher';\n// TODO(osp) re-enable type specific constructors\n// They are nice to have but not absolutely necessary\n// import type {\n//   CipherCCMOptions,\n//   CipherCCMTypes,\n//   CipherGCMTypes,\n//   CipherGCMOptions,\n//   // CipherKey,\n//   // KeyObject,\n//   // TODO(Szymon) This types seem to be missing? Where did you get this definitions from?\n//   // CipherOCBTypes,\n//   // CipherOCBOptions,\n// } from 'crypto'; // Node crypto typings\nimport { StringDecoder } from 'string_decoder';\nimport { Buffer } from '@craftzdog/react-native-buffer';\nimport { Buffer as SBuffer } from 'safe-buffer';\nimport { constants } from './constants';\nimport {\n  parsePrivateKeyEncoding,\n  parsePublicKeyEncoding,\n  preparePrivateKey,\n  preparePublicOrPrivateKey,\n} from './keys';\n\n// make sure that nextTick is there\nglobal.process.nextTick = setImmediate;\n\nconst createInternalCipher = NativeQuickCrypto.createCipher;\nconst createInternalDecipher = NativeQuickCrypto.createDecipher;\nconst _publicEncrypt = NativeQuickCrypto.publicEncrypt;\nconst _publicDecrypt = NativeQuickCrypto.publicDecrypt;\nconst _privateDecrypt = NativeQuickCrypto.privateDecrypt;\n\nfunction getUIntOption(options: Record<string, any>, key: string) {\n  let value;\n  if (options && (value = options[key]) != null) {\n    // >>> Turns any type into a positive integer (also sets the sign bit to 0)\n    // eslint-disable-next-line no-bitwise\n    if (value >>> 0 !== value) throw new Error(`options.${key}: ${value}`);\n    return value;\n  }\n  return -1;\n}\n\nfunction normalizeEncoding(enc: string) {\n  if (!enc) return 'utf8';\n  var retried;\n  while (true) {\n    switch (enc) {\n      case 'utf8':\n      case 'utf-8':\n        return 'utf8';\n      case 'ucs2':\n      case 'ucs-2':\n      case 'utf16le':\n      case 'utf-16le':\n        return 'utf16le';\n      case 'latin1':\n      case 'binary':\n        return 'latin1';\n      case 'base64':\n      case 'ascii':\n      case 'hex':\n        return enc;\n      default:\n        if (retried) return; // undefined\n        enc = ('' + enc).toLowerCase();\n        retried = true;\n    }\n  }\n}\n\nfunction validateEncoding(data: string, encoding: string) {\n  const normalizedEncoding = normalizeEncoding(encoding);\n  const length = data.length;\n\n  if (normalizedEncoding === 'hex' && length % 2 !== 0) {\n    throw new Error(`Encoding ${encoding} not valid for data length ${length}`);\n  }\n}\n\nfunction getDecoder(decoder?: StringDecoder, encoding?: BufferEncoding) {\n  return decoder ?? new StringDecoder(encoding);\n}\n\nclass CipherCommon extends Stream.Transform {\n  private internal: InternalCipher;\n  private decoder: StringDecoder | undefined;\n\n  constructor(\n    cipherType: string,\n    cipherKey: BinaryLike,\n    isCipher: boolean,\n    options: Record<string, any> = {},\n    iv?: BinaryLike | null\n  ) {\n    super(options);\n    const cipherKeyBuffer = binaryLikeToArrayBuffer(cipherKey);\n    // TODO(osp) This might not be smart, check again after release\n    const authTagLength = getUIntOption(options, 'authTagLength');\n    const args = {\n      cipher_type: cipherType,\n      cipher_key: cipherKeyBuffer,\n      iv,\n      ...options,\n      auth_tag_len: authTagLength,\n    };\n    this.internal = isCipher\n      ? createInternalCipher(args)\n      : createInternalDecipher(args);\n  }\n\n  update(\n    data: BinaryLike,\n    inputEncoding?: CipherEncoding,\n    outputEncoding?: CipherEncoding\n  ): ArrayBuffer | string {\n    const defaultEncoding = getDefaultEncoding();\n    inputEncoding = inputEncoding ?? defaultEncoding;\n    outputEncoding = outputEncoding ?? defaultEncoding;\n\n    if (typeof data === 'string') {\n      validateEncoding(data, inputEncoding);\n    } else if (!ArrayBuffer.isView(data)) {\n      throw new Error('Invalid data argument');\n    }\n\n    if (typeof data === 'string') {\n      // On node this is handled on the native side\n      // on our case we need to correctly send the arraybuffer to the jsi side\n      inputEncoding = inputEncoding === 'buffer' ? 'utf8' : inputEncoding;\n      data = binaryLikeToArrayBuffer(data, inputEncoding);\n    } else {\n      data = binaryLikeToArrayBuffer(data as any, inputEncoding);\n    }\n\n    const ret = this.internal.update(data);\n\n    if (outputEncoding && outputEncoding !== 'buffer') {\n      this.decoder = getDecoder(this.decoder, outputEncoding);\n\n      return this.decoder!.write(SBuffer.from(ret) as any);\n    }\n\n    return ret;\n  }\n\n  final(): ArrayBuffer;\n  final(outputEncoding: BufferEncoding | 'buffer'): string;\n  final(outputEncoding?: BufferEncoding | 'buffer'): ArrayBuffer | string {\n    const ret = this.internal.final();\n\n    if (outputEncoding && outputEncoding !== 'buffer') {\n      this.decoder = getDecoder(this.decoder, outputEncoding);\n\n      return this.decoder!.end(SBuffer.from(ret) as any);\n    }\n\n    return ret;\n  }\n\n  _transform(chunk: BinaryLike, encoding: Encoding, callback: () => void) {\n    this.push(this.update(chunk, encoding));\n    callback();\n  }\n\n  _flush(callback: () => void) {\n    this.push(this.final());\n    callback();\n  }\n\n  public setAutoPadding(autoPadding?: boolean): this {\n    this.internal.setAutoPadding(!!autoPadding);\n    return this;\n  }\n\n  public setAAD(\n    buffer: Buffer,\n    options?: {\n      plaintextLength: number;\n    }\n  ): this {\n    this.internal.setAAD({\n      data: buffer.buffer,\n      plaintextLength: options?.plaintextLength,\n    });\n    return this;\n  }\n\n  // protected getAuthTag(): Buffer {\n  //   return Buffer.from(this.internal.getAuthTag());\n  // }\n\n  public setAuthTag(tag: Buffer): this {\n    this.internal.setAuthTag(tag.buffer);\n    return this;\n  }\n}\n\nclass Cipher extends CipherCommon {\n  constructor(\n    cipherType: string,\n    cipherKey: BinaryLike,\n    options: Record<string, any> = {},\n    iv?: BinaryLike | null\n  ) {\n    if (iv != null) {\n      iv = binaryLikeToArrayBuffer(iv);\n    }\n    super(cipherType, cipherKey, true, options, iv);\n  }\n}\n\nclass Decipher extends CipherCommon {\n  constructor(\n    cipherType: string,\n    cipherKey: BinaryLike,\n    options: Record<string, any> = {},\n    iv?: BinaryLike | null\n  ) {\n    if (iv != null) {\n      iv = binaryLikeToArrayBuffer(iv);\n    }\n\n    super(cipherType, cipherKey, false, options, iv);\n  }\n}\n\n// TODO(osp) This definitions cause typescript errors when using the API\n// export function createDecipher(\n//   algorithm: CipherCCMTypes,\n//   password: BinaryLike,\n//   options: CipherCCMOptions\n// ): Decipher;\n// export function createDecipher(\n//   algorithm: CipherGCMTypes,\n//   password: BinaryLike,\n//   options?: CipherGCMOptions\n// ): Decipher;\nexport function createDecipher(\n  algorithm: string,\n  password: BinaryLike,\n  options?: Stream.TransformOptions\n): Decipher {\n  return new Decipher(algorithm, password, options);\n}\n\n// TODO(osp) This definitions cause typescript errors when using the API\n// export function createDecipheriv(\n//   algorithm: CipherCCMTypes,\n//   key: BinaryLike,\n//   iv: BinaryLike,\n//   options: CipherCCMOptions\n// ): Decipher;\n// export function createDecipheriv(\n//   algorithm: CipherOCBTypes,\n//   key: BinaryLike,\n//   iv: BinaryLike,\n//   options: CipherOCBOptions\n// ): DecipherOCB;\n// export function createDecipheriv(\n//   algorithm: CipherGCMTypes,\n//   key: BinaryLike,\n//   iv: BinaryLike,\n//   options?: CipherGCMOptions\n// ): Decipher;\nexport function createDecipheriv(\n  algorithm: string,\n  key: BinaryLike,\n  iv: BinaryLike | null,\n  options?: Stream.TransformOptions\n): Decipher {\n  return new Decipher(algorithm, key, options, iv);\n}\n\n// TODO(osp) This definitions cause typescript errors when using the API\n// commenting them out for now\n// export function createCipher(\n//   algorithm: CipherCCMTypes,\n//   password: BinaryLike,\n//   options: CipherCCMOptions\n// ): Cipher;\n// export function createCipher(\n//   algorithm: CipherGCMTypes,\n//   password: BinaryLike,\n//   options?: CipherGCMOptions\n// ): Cipher;\nexport function createCipher(\n  algorithm: string,\n  password: BinaryLike,\n  options?: Stream.TransformOptions\n): Cipher {\n  return new Cipher(algorithm, password, options);\n}\n\n// TODO(osp) on all the createCipheriv methods, node seems to use a \"KeyObject\" is seems to be a thread safe\n// object that creates keys and what not. Not sure if we should support it.\n// Fow now I replaced all of them to BinaryLike\n// export function createCipheriv(\n//   algorithm: CipherCCMTypes,\n//   key: BinaryLike,\n//   iv: BinaryLike,\n//   options: CipherCCMOptions\n// ): Cipher;\n// export function createCipheriv(\n//   algorithm: CipherOCBTypes,\n//   key: BinaryLike,\n//   iv: BinaryLike,\n//   options: CipherOCBOptions\n// ): CipherOCB;\n// export function createCipheriv(\n//   algorithm: CipherGCMTypes,\n//   key: BinaryLike,\n//   iv: BinaryLike,\n//   options?: CipherGCMOptions\n// ): Cipher;\nexport function createCipheriv(\n  algorithm: string,\n  key: BinaryLike,\n  iv: BinaryLike | null,\n  options?: Stream.TransformOptions\n): Cipher {\n  return new Cipher(algorithm, key, options, iv);\n}\n\n// RSA Functions\n// Follows closely the model implemented in node\n\n// TODO(osp) types...\nfunction rsaFunctionFor(\n  method: (\n    data: ArrayBuffer,\n    format: number,\n    type: any,\n    passphrase: any,\n    buffer: ArrayBuffer,\n    padding: number,\n    oaepHash: any,\n    oaepLabel: any\n  ) => Buffer,\n  defaultPadding: number,\n  keyType: 'public' | 'private'\n) {\n  return (\n    options: {\n      key: any;\n      encoding?: string;\n      format?: any;\n      padding?: any;\n      oaepHash?: any;\n      oaepLabel?: any;\n      passphrase?: string;\n    },\n    buffer: BinaryLike\n  ) => {\n    const { format, type, data, passphrase } =\n      keyType === 'private'\n        ? preparePrivateKey(options)\n        : preparePublicOrPrivateKey(options);\n    const padding = options.padding || defaultPadding;\n    const { oaepHash, encoding } = options;\n    let { oaepLabel } = options;\n    if (oaepHash !== undefined) validateString(oaepHash, 'key.oaepHash');\n    if (oaepLabel !== undefined)\n      oaepLabel = binaryLikeToArrayBuffer(oaepLabel, encoding);\n    buffer = binaryLikeToArrayBuffer(buffer, encoding);\n\n    const rawRes = method(\n      data,\n      format,\n      type,\n      passphrase,\n      buffer,\n      padding,\n      oaepHash,\n      oaepLabel\n    );\n\n    return Buffer.from(rawRes);\n  };\n}\n\nexport const publicEncrypt = rsaFunctionFor(\n  _publicEncrypt,\n  constants.RSA_PKCS1_OAEP_PADDING,\n  'public'\n);\nexport const publicDecrypt = rsaFunctionFor(\n  _publicDecrypt,\n  constants.RSA_PKCS1_PADDING,\n  'public'\n);\n// const privateEncrypt = rsaFunctionFor(_privateEncrypt, constants.RSA_PKCS1_PADDING,\n//   'private');\nexport const privateDecrypt = rsaFunctionFor(\n  _privateDecrypt,\n  constants.RSA_PKCS1_OAEP_PADDING,\n  'private'\n);\n\n//                                   _       _  __          _____      _\n//                                  | |     | |/ /         |  __ \\    (_)\n//    __ _  ___ _ __   ___ _ __ __ _| |_ ___| ' / ___ _   _| |__) |_ _ _ _ __\n//   / _` |/ _ \\ '_ \\ / _ \\ '__/ _` | __/ _ \\  < / _ \\ | | |  ___/ _` | | '__|\n//  | (_| |  __/ | | |  __/ | | (_| | ||  __/ . \\  __/ |_| | |  | (_| | | |\n//   \\__, |\\___|_| |_|\\___|_|  \\__,_|\\__\\___|_|\\_\\___|\\__, |_|   \\__,_|_|_|\n//    __/ |                                            __/ |\n//   |___/                                            |___/\ntype GenerateKeyPairOptions = {\n  modulusLength: number; // Key size in bits (RSA, DSA).\n  publicExponent?: number; // Public exponent (RSA). Default: 0x10001.\n  hashAlgorithm?: string; // Name of the message digest (RSA-PSS).\n  mgf1HashAlgorithm?: string; // string Name of the message digest used by MGF1 (RSA-PSS).\n  saltLength?: number; // Minimal salt length in bytes (RSA-PSS).\n  divisorLength?: number; // Size of q in bits (DSA).\n  namedCurve?: string; // Name of the curve to use (EC).\n  prime?: Buffer; // The prime parameter (DH).\n  primeLength?: number; // Prime length in bits (DH).\n  generator?: number; // Custom generator (DH). Default: 2.\n  groupName?: string; // Diffie-Hellman group name (DH). See crypto.getDiffieHellman().\n  publicKeyEncoding?: any; // See keyObject.export().\n  privateKeyEncoding?: any; // See keyObject.export().\n  paramEncoding?: string;\n  hash?: any;\n  mgf1Hash?: any;\n};\ntype GenerateKeyPairCallback = (\n  error: unknown | null,\n  publicKey?: Buffer,\n  privateKey?: Buffer\n) => void;\n\nfunction parseKeyEncoding(\n  keyType: string,\n  options: GenerateKeyPairOptions = kEmptyObject\n) {\n  const { publicKeyEncoding, privateKeyEncoding } = options;\n\n  let publicFormat, publicType;\n  if (publicKeyEncoding == null) {\n    publicFormat = publicType = undefined;\n  } else if (typeof publicKeyEncoding === 'object') {\n    ({ format: publicFormat, type: publicType } = parsePublicKeyEncoding(\n      publicKeyEncoding,\n      keyType,\n      'publicKeyEncoding'\n    ));\n  } else {\n    throw new Error(\n      'Invalid argument options.publicKeyEncoding',\n      publicKeyEncoding\n    );\n  }\n\n  let privateFormat, privateType, cipher, passphrase;\n  if (privateKeyEncoding == null) {\n    privateFormat = privateType = undefined;\n  } else if (typeof privateKeyEncoding === 'object') {\n    ({\n      format: privateFormat,\n      type: privateType,\n      cipher,\n      passphrase,\n    } = parsePrivateKeyEncoding(\n      privateKeyEncoding,\n      keyType,\n      'privateKeyEncoding'\n    ));\n  } else {\n    throw new Error(\n      'Invalid argument options.privateKeyEncoding',\n      publicKeyEncoding\n    );\n  }\n\n  return [\n    publicFormat,\n    publicType,\n    privateFormat,\n    privateType,\n    cipher,\n    passphrase,\n  ];\n}\n\nfunction internalGenerateKeyPair(\n  isAsync: boolean,\n  type: string,\n  options: GenerateKeyPairOptions | undefined,\n  callback: GenerateKeyPairCallback | undefined\n) {\n  // On node a very complex \"job\" chain is created, we are going for a far simpler approach and calling\n  // an internal function that basically executes the same byte shuffling on the native side\n  const encoding = parseKeyEncoding(type, options);\n\n  // if (options !== undefined)\n  //   validateObject(options, 'options');\n\n  switch (type) {\n    case 'rsa-pss':\n    case 'rsa': {\n      validateObject<GenerateKeyPairOptions>(options, 'options');\n      const { modulusLength } = options!;\n      validateUint32(modulusLength, 'options.modulusLength');\n\n      let { publicExponent } = options!;\n      if (publicExponent == null) {\n        publicExponent = 0x10001;\n      } else {\n        validateUint32(publicExponent, 'options.publicExponent');\n      }\n\n      if (type === 'rsa') {\n        if (isAsync) {\n          NativeQuickCrypto.generateKeyPair(\n            RSAKeyVariant.kKeyVariantRSA_SSA_PKCS1_v1_5,\n            modulusLength,\n            publicExponent,\n            ...encoding\n          )\n            .then(([err, publicKey, privateKey]) => {\n              if (typeof publicKey === 'object') {\n                publicKey = Buffer.from(publicKey);\n              }\n              if (typeof privateKey === 'object') {\n                privateKey = Buffer.from(privateKey);\n              }\n              callback?.(err, publicKey, privateKey);\n            })\n            .catch((err) => {\n              callback?.(err, undefined, undefined);\n            });\n          return;\n        } else {\n          let [err, publicKey, privateKey] =\n            NativeQuickCrypto.generateKeyPairSync(\n              RSAKeyVariant.kKeyVariantRSA_SSA_PKCS1_v1_5,\n              modulusLength,\n              publicExponent,\n              ...encoding\n            );\n\n          if (typeof publicKey === 'object') {\n            publicKey = Buffer.from(publicKey);\n          }\n          if (typeof privateKey === 'object') {\n            privateKey = Buffer.from(privateKey);\n          }\n\n          return [err, publicKey, privateKey];\n        }\n      }\n\n      const { hash, mgf1Hash, hashAlgorithm, mgf1HashAlgorithm, saltLength } =\n        options!;\n\n      // // We don't have a process object on RN\n      // // const pendingDeprecation = getOptionValue('--pending-deprecation');\n\n      if (saltLength !== undefined)\n        validateInt32(saltLength, 'options.saltLength', 0);\n      if (hashAlgorithm !== undefined)\n        validateString(hashAlgorithm, 'options.hashAlgorithm');\n      if (mgf1HashAlgorithm !== undefined)\n        validateString(mgf1HashAlgorithm, 'options.mgf1HashAlgorithm');\n      if (hash !== undefined) {\n        // pendingDeprecation && process.emitWarning(\n        //   '\"options.hash\" is deprecated, ' +\n        //   'use \"options.hashAlgorithm\" instead.',\n        //   'DeprecationWarning',\n        //   'DEP0154');\n        validateString(hash, 'options.hash');\n        if (hashAlgorithm && hash !== hashAlgorithm) {\n          throw new Error(`Invalid Argument options.hash ${hash}`);\n        }\n      }\n      if (mgf1Hash !== undefined) {\n        // pendingDeprecation && process.emitWarning(\n        //   '\"options.mgf1Hash\" is deprecated, ' +\n        //   'use \"options.mgf1HashAlgorithm\" instead.',\n        //   'DeprecationWarning',\n        //   'DEP0154');\n        validateString(mgf1Hash, 'options.mgf1Hash');\n        if (mgf1HashAlgorithm && mgf1Hash !== mgf1HashAlgorithm) {\n          throw new Error(`Invalid Argument options.mgf1Hash ${mgf1Hash}`);\n        }\n      }\n\n      return NativeQuickCrypto.generateKeyPairSync(\n        RSAKeyVariant.kKeyVariantRSA_PSS,\n        modulusLength,\n        publicExponent,\n        hashAlgorithm || hash,\n        mgf1HashAlgorithm || mgf1Hash,\n        saltLength,\n        ...encoding\n      );\n    }\n    // case 'dsa': {\n    //   validateObject(options, 'options');\n    //   const { modulusLength } = options!;\n    //   validateUint32(modulusLength, 'options.modulusLength');\n\n    //   let { divisorLength } = options!;\n    //   if (divisorLength == null) {\n    //     divisorLength = -1;\n    //   } else validateInt32(divisorLength, 'options.divisorLength', 0);\n\n    //   // return new DsaKeyPairGenJob(\n    //   //   mode,\n    //   //   modulusLength,\n    //   //   divisorLength,\n    //   //   ...encoding);\n    // }\n    // case 'ec': {\n    //   validateObject(options, 'options');\n    //   const { namedCurve } = options!;\n    //   validateString(namedCurve, 'options.namedCurve');\n    //   let { paramEncoding } = options!;\n    //   if (paramEncoding == null || paramEncoding === 'named')\n    //     paramEncoding = OPENSSL_EC_NAMED_CURVE;\n    //   else if (paramEncoding === 'explicit')\n    //     paramEncoding = OPENSSL_EC_EXPLICIT_CURVE;\n    //   else\n    //   throw new Error(`Invalid Argument options.paramEncoding ${paramEncoding}`);\n    //     // throw new ERR_INVALID_ARG_VALUE('options.paramEncoding', paramEncoding);\n\n    //   // return new EcKeyPairGenJob(mode, namedCurve, paramEncoding, ...encoding);\n    // }\n    // case 'ed25519':\n    // case 'ed448':\n    // case 'x25519':\n    // case 'x448': {\n    //   let id;\n    //   switch (type) {\n    //     case 'ed25519':\n    //       id = EVP_PKEY_ED25519;\n    //       break;\n    //     case 'ed448':\n    //       id = EVP_PKEY_ED448;\n    //       break;\n    //     case 'x25519':\n    //       id = EVP_PKEY_X25519;\n    //       break;\n    //     case 'x448':\n    //       id = EVP_PKEY_X448;\n    //       break;\n    //   }\n    //   return new NidKeyPairGenJob(mode, id, ...encoding);\n    // }\n    // case 'dh': {\n    //   validateObject(options, 'options');\n    //   const { group, primeLength, prime, generator } = options;\n    //   if (group != null) {\n    //     if (prime != null)\n    //       throw new ERR_INCOMPATIBLE_OPTION_PAIR('group', 'prime');\n    //     if (primeLength != null)\n    //       throw new ERR_INCOMPATIBLE_OPTION_PAIR('group', 'primeLength');\n    //     if (generator != null)\n    //       throw new ERR_INCOMPATIBLE_OPTION_PAIR('group', 'generator');\n\n    //     validateString(group, 'options.group');\n\n    //     return new DhKeyPairGenJob(mode, group, ...encoding);\n    //   }\n\n    //   if (prime != null) {\n    //     if (primeLength != null)\n    //       throw new ERR_INCOMPATIBLE_OPTION_PAIR('prime', 'primeLength');\n\n    //     validateBuffer(prime, 'options.prime');\n    //   } else if (primeLength != null) {\n    //     validateInt32(primeLength, 'options.primeLength', 0);\n    //   } else {\n    //     throw new ERR_MISSING_OPTION(\n    //       'At least one of the group, prime, or primeLength options'\n    //     );\n    //   }\n\n    //   if (generator != null) {\n    //     validateInt32(generator, 'options.generator', 0);\n    //   }\n    //   return new DhKeyPairGenJob(\n    //     mode,\n    //     prime != null ? prime : primeLength,\n    //     generator == null ? 2 : generator,\n    //     ...encoding\n    //   );\n    // }\n    default:\n    // Fall through\n  }\n  throw new Error(\n    `Invalid Argument options: ${type} scheme not supported. Currently not all encryption methods are supported in quick-crypto!`\n  );\n}\n\n// TODO(osp) put correct types (e.g. type -> 'rsa', etc..)\nexport function generateKeyPair(\n  type: string,\n  callback: GenerateKeyPairCallback\n): void;\nexport function generateKeyPair(\n  type: string,\n  options: GenerateKeyPairOptions,\n  callback: GenerateKeyPairCallback\n): void;\nexport function generateKeyPair(\n  type: string,\n  options?: GenerateKeyPairCallback | GenerateKeyPairOptions,\n  callback?: GenerateKeyPairCallback\n) {\n  if (typeof options === 'function') {\n    callback = options;\n    options = undefined;\n  }\n\n  validateFunction(callback);\n\n  internalGenerateKeyPair(true, type, options, callback);\n}\n\nexport function generateKeyPairSync(type: string): {\n  publicKey: any;\n  privateKey: any;\n};\nexport function generateKeyPairSync(\n  type: string,\n  options: GenerateKeyPairOptions\n): { publicKey: any; privateKey: any };\nexport function generateKeyPairSync(\n  type: string,\n  options?: GenerateKeyPairOptions\n): { publicKey: any; privateKey: any } {\n  const [_, publicKey, privateKey] = internalGenerateKeyPair(\n    false,\n    type,\n    options,\n    undefined\n  )!;\n\n  return {\n    publicKey,\n    privateKey,\n  };\n}\n"]}