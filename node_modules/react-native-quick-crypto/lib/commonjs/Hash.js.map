{"version":3,"sources":["Hash.ts"],"names":["global","process","nextTick","setImmediate","createInternalHash","NativeQuickCrypto","createHash","algorithm","options","Hash","Stream","Transform","constructor","arg","undefined","internalHash","copy","outputLength","update","data","inputEncoding","ArrayBuffer","buffer","Buffer","from","_transform","chunk","encoding","callback","_flush","push","digest","result","toString"],"mappings":";;;;;;;AACA;;AACA;;AAEA;;AACA;;AACA;;;;;;AAOAA,MAAM,CAACC,OAAP,CAAeC,QAAf,GAA0BC,YAA1B;AAEA,MAAMC,kBAAkB,GAAGC,qCAAkBC,UAA7C;;AAIO,SAASA,UAAT,CAAoBC,SAApB,EAAuCC,OAAvC,EAA8D;AACnE,SAAO,IAAIC,IAAJ,CAASF,SAAT,EAAoBC,OAApB,CAAP;AACD;;AAED,MAAMC,IAAN,SAAmBC,0BAAOC,SAA1B,CAAoC;AAKlCC,EAAAA,WAAW,CAACC,GAAD,EAAqBL,OAArB,EAA4C;AACrD,UAAMA,OAAN,aAAMA,OAAN,cAAMA,OAAN,GAAiBM,SAAjB;;AADqD;;AAErD,QAAID,GAAG,YAAYJ,IAAnB,EAAyB;AACvB,WAAKM,YAAL,GAAoBF,GAAG,CAACE,YAAJ,CAAiBC,IAAjB,CAAsBR,OAAtB,aAAsBA,OAAtB,uBAAsBA,OAAO,CAAES,YAA/B,CAApB;AACD,KAFD,MAEO;AACL,WAAKF,YAAL,GAAoBX,kBAAkB,CAACS,GAAD,EAAML,OAAN,aAAMA,OAAN,uBAAMA,OAAO,CAAES,YAAf,CAAtC;AACD;AACF;;AAEDD,EAAAA,IAAI,CAACR,OAAD,EAAkC;AACpC,UAAMQ,IAAI,GAAG,IAAIP,IAAJ,CAAS,IAAT,EAAeD,OAAf,CAAb;AACA,WAAOQ,IAAP;AACD;AACD;AACF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AACEE,EAAAA,MAAM,CAACC,IAAD,EAA4BC,aAA5B,EAA4D;AAChE,QAAID,IAAI,YAAYE,WAApB,EAAiC;AAC/B,WAAKN,YAAL,CAAkBG,MAAlB,CAAyBC,IAAzB;AACA,aAAO,IAAP;AACD;;AACD,UAAMG,MAAM,GAAGC,0BAAOC,IAAP,CAAYL,IAAZ,EAAkBC,aAAlB,CAAf;;AACA,SAAKL,YAAL,CAAkBG,MAAlB,CAAyB,0BAAcI,MAAd,CAAzB;AACA,WAAO,IAAP;AACD;;AAEDG,EAAAA,UAAU,CACRC,KADQ,EAERC,QAFQ,EAGRC,QAHQ,EAIR;AACA,SAAKV,MAAL,CAAYQ,KAAZ,EAAmBC,QAAnB;AACAC,IAAAA,QAAQ;AACT;;AAEDC,EAAAA,MAAM,CAACD,QAAD,EAAuB;AAC3B,SAAKE,IAAL,CAAU,KAAKC,MAAL,EAAV;AACAH,IAAAA,QAAQ;AACT;AAED;AACF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AAIEG,EAAAA,MAAM,CAACJ,QAAD,EAAkD;AACtD,UAAMK,MAAmB,GAAG,KAAKjB,YAAL,CAAkBgB,MAAlB,EAA5B;;AAEA,QAAIJ,QAAQ,IAAIA,QAAQ,KAAK,QAA7B,EAAuC;AACrC,aAAOJ,0BAAOC,IAAP,CAAYQ,MAAZ,EAAoBC,QAApB,CAA6BN,QAA7B,CAAP;AACD;;AAED,WAAOJ,0BAAOC,IAAP,CAAYQ,MAAZ,CAAP;AACD;;AAzEiC","sourcesContent":["/* eslint-disable no-dupe-class-members */\nimport 'react-native';\nimport { NativeQuickCrypto } from './NativeQuickCrypto/NativeQuickCrypto';\nimport type { InternalHash } from './NativeQuickCrypto/hash';\nimport { Encoding, toArrayBuffer } from './Utils';\nimport Stream from 'stream-browserify';\nimport { Buffer } from '@craftzdog/react-native-buffer';\ninterface HashOptionsBase extends Stream.TransformOptions {\n  outputLength?: number | undefined;\n}\n\ntype HashOptions = null | undefined | HashOptionsBase;\n\nglobal.process.nextTick = setImmediate;\n\nconst createInternalHash = NativeQuickCrypto.createHash;\n\ntype BinaryLike = ArrayBuffer;\n\nexport function createHash(algorithm: string, options?: HashOptions) {\n  return new Hash(algorithm, options);\n}\n\nclass Hash extends Stream.Transform {\n  private internalHash: InternalHash;\n\n  constructor(other: Hash, options?: HashOptions);\n  constructor(algorithm: string, options?: HashOptions);\n  constructor(arg: string | Hash, options?: HashOptions) {\n    super(options ?? undefined);\n    if (arg instanceof Hash) {\n      this.internalHash = arg.internalHash.copy(options?.outputLength);\n    } else {\n      this.internalHash = createInternalHash(arg, options?.outputLength);\n    }\n  }\n\n  copy(options?: HashOptionsBase): Hash {\n    const copy = new Hash(this, options);\n    return copy;\n  }\n  /**\n   * Updates the hash content with the given `data`, the encoding of which\n   * is given in `inputEncoding`.\n   * If `encoding` is not provided, and the `data` is a string, an\n   * encoding of `'utf8'` is enforced. If `data` is a `Buffer`, `TypedArray`, or`DataView`, then `inputEncoding` is ignored.\n   *\n   * This can be called many times with new data as it is streamed.\n   * @since v0.1.92\n   * @param inputEncoding The `encoding` of the `data` string.\n   */\n  update(data: string | BinaryLike, inputEncoding?: Encoding): Hash {\n    if (data instanceof ArrayBuffer) {\n      this.internalHash.update(data);\n      return this;\n    }\n    const buffer = Buffer.from(data, inputEncoding);\n    this.internalHash.update(toArrayBuffer(buffer));\n    return this;\n  }\n\n  _transform(\n    chunk: string | BinaryLike,\n    encoding: Encoding,\n    callback: () => void\n  ) {\n    this.update(chunk, encoding);\n    callback();\n  }\n\n  _flush(callback: () => void) {\n    this.push(this.digest());\n    callback();\n  }\n\n  /**\n   * Calculates the digest of all of the data passed to be hashed (using the `hash.update()` method).\n   * If `encoding` is provided a string will be returned; otherwise\n   * a `Buffer` is returned.\n   *\n   * The `Hash` object can not be used again after `hash.digest()` method has been\n   * called. Multiple calls will cause an error to be thrown.\n   * @since v0.1.92\n   * @param encoding The `encoding` of the return value.\n   */\n  digest(): Buffer;\n  digest(encoding: 'buffer'): Buffer;\n  digest(encoding: Encoding): string;\n  digest(encoding?: Encoding | 'buffer'): string | Buffer {\n    const result: ArrayBuffer = this.internalHash.digest();\n\n    if (encoding && encoding !== 'buffer') {\n      return Buffer.from(result).toString(encoding);\n    }\n\n    return Buffer.from(result);\n  }\n}\n"]}