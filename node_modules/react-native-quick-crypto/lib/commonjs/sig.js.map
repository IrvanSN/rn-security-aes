{"version":3,"sources":["sig.ts"],"names":["DSASigEnc","createInternalSign","NativeQuickCrypto","createSign","createInternalVerify","createVerify","getPadding","options","getIntOption","getSaltLength","getDSASignatureEncoding","dsaEncoding","kSigEncDER","kSigEncP1363","Error","name","value","undefined","Verify","Stream","Writable","constructor","algorithm","internal","init","_write","chunk","encoding","callback","update","data","verify","signature","format","type","passphrase","rsaPadding","pssSaltLength","dsaSigEnc","ret","Sign","sign","Buffer","from","toString"],"mappings":"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","sourcesContent":["import { NativeQuickCrypto } from './NativeQuickCrypto/NativeQuickCrypto';\nimport type { InternalSign, InternalVerify } from './NativeQuickCrypto/sig';\nimport Stream from 'stream-browserify';\n\n// TODO(osp) same as publicCipher on node this are defined on C++ and exposed to node\n// Do the same here\nenum DSASigEnc {\n  kSigEncDER,\n  kSigEncP1363,\n}\n\nimport {\n  BinaryLike,\n  binaryLikeToArrayBuffer,\n  getDefaultEncoding,\n} from './Utils';\nimport { preparePrivateKey, preparePublicOrPrivateKey } from './keys';\n\nconst createInternalSign = NativeQuickCrypto.createSign;\nconst createInternalVerify = NativeQuickCrypto.createVerify;\n\nfunction getPadding(options: any) {\n  return getIntOption('padding', options);\n}\n\nfunction getSaltLength(options: any) {\n  return getIntOption('saltLength', options);\n}\n\nfunction getDSASignatureEncoding(options: any) {\n  if (typeof options === 'object') {\n    const { dsaEncoding = 'der' } = options;\n    if (dsaEncoding === 'der') return DSASigEnc.kSigEncDER;\n    else if (dsaEncoding === 'ieee-p1363') return DSASigEnc.kSigEncP1363;\n    throw new Error(`options.dsaEncoding: ${dsaEncoding} not a valid encoding`);\n  }\n\n  return DSASigEnc.kSigEncDER;\n}\n\nfunction getIntOption(name: string, options: any) {\n  const value = options[name];\n  if (value !== undefined) {\n    if (value === value >> 0) {\n      return value;\n    }\n    throw new Error(`options.${name}: ${value} not a valid int value`);\n  }\n  return undefined;\n}\n\nclass Verify extends Stream.Writable {\n  private internal: InternalVerify;\n  constructor(algorithm: string, options: Stream.WritableOptions) {\n    super(options);\n    this.internal = createInternalVerify();\n    this.internal.init(algorithm);\n  }\n\n  _write(chunk: BinaryLike, encoding: string, callback: () => void) {\n    this.update(chunk, encoding);\n    callback();\n  }\n\n  update(data: BinaryLike, encoding?: string) {\n    encoding = encoding ?? getDefaultEncoding();\n    data = binaryLikeToArrayBuffer(data, encoding);\n    this.internal.update(data);\n    return this;\n  }\n\n  verify(\n    options: {\n      key: string | Buffer;\n      format?: string;\n      type?: string;\n      passphrase?: string;\n      padding?: number;\n      saltLength?: number;\n    },\n    signature: BinaryLike\n  ): boolean {\n    if (!options) {\n      throw new Error('Crypto sign key required');\n    }\n\n    const { data, format, type, passphrase } =\n      preparePublicOrPrivateKey(options);\n\n    const rsaPadding = getPadding(options);\n    const pssSaltLength = getSaltLength(options);\n\n    // Options specific to (EC)DSA\n    const dsaSigEnc = getDSASignatureEncoding(options);\n\n    const ret = this.internal.verify(\n      data,\n      format,\n      type,\n      passphrase,\n      binaryLikeToArrayBuffer(signature),\n      rsaPadding,\n      pssSaltLength,\n      dsaSigEnc\n    );\n\n    return ret;\n  }\n}\n\nclass Sign extends Stream.Writable {\n  private internal: InternalSign;\n  constructor(algorithm: string, options: Stream.WritableOptions) {\n    super(options);\n    this.internal = createInternalSign();\n    this.internal.init(algorithm);\n  }\n\n  _write(chunk: BinaryLike, encoding: string, callback: () => void) {\n    this.update(chunk, encoding);\n    callback();\n  }\n\n  update(data: BinaryLike, encoding?: string) {\n    encoding = encoding ?? getDefaultEncoding();\n    data = binaryLikeToArrayBuffer(data, encoding);\n    this.internal.update(data);\n    return this;\n  }\n\n  sign(\n    options: {\n      key: string | Buffer;\n      format?: string;\n      type?: string;\n      passphrase?: string;\n      padding?: number;\n      saltLength?: number;\n    },\n    encoding?: string\n  ) {\n    if (!options) {\n      throw new Error('Crypto sign key required');\n    }\n\n    const { data, format, type, passphrase } = preparePrivateKey(options);\n\n    const rsaPadding = getPadding(options);\n    const pssSaltLength = getSaltLength(options);\n\n    // Options specific to (EC)DSA\n    const dsaSigEnc = getDSASignatureEncoding(options);\n\n    const ret = this.internal.sign(\n      data,\n      format,\n      type,\n      passphrase,\n      rsaPadding,\n      pssSaltLength,\n      dsaSigEnc\n    );\n\n    encoding = encoding || getDefaultEncoding();\n    if (encoding && encoding !== 'buffer') {\n      return Buffer.from(ret).toString(encoding as any);\n    }\n\n    return Buffer.from(ret);\n  }\n}\n\nexport function createSign(algorithm: string, options?: any) {\n  return new Sign(algorithm, options);\n}\n\nexport function createVerify(algorithm: string, options?: any) {\n  return new Verify(algorithm, options);\n}\n"]}