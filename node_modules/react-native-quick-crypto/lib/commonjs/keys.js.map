{"version":3,"sources":["keys.ts"],"names":["KFormatType","KeyInputContext","KeyEncoding","encodingNames","kKeyEncodingPKCS1","kKeyEncodingPKCS8","kKeyEncodingSPKI","kKeyEncodingSEC1","option","name","objName","undefined","parseKeyFormat","formatStr","defaultFormat","optionName","kKeyFormatPEM","kKeyFormatDER","kKeyFormatJWK","Error","parseKeyType","typeStr","required","keyType","isPublic","parseKeyFormatAndType","enc","format","type","isInput","isRequired","parseKeyEncoding","cipher","passphrase","encoding","prepareAsymmetricKey","key","ctx","data","kConsumePrivate","kCreatePrivate","preparePrivateKey","preparePublicOrPrivateKey","kConsumePublic","parsePublicKeyEncoding","parsePrivateKeyEncoding"],"mappings":"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","sourcesContent":["import { BinaryLike, binaryLikeToArrayBuffer, isStringOrBuffer } from './Utils';\n\n// On node this value is defined on the native side, for now I'm just creating it here in JS\n// TODO(osp) move this into native side to make sure they always match\nenum KFormatType {\n  kKeyFormatDER,\n  kKeyFormatPEM,\n  kKeyFormatJWK,\n}\n\nenum KeyInputContext {\n  kConsumePublic,\n  kConsumePrivate,\n  kCreatePublic,\n  kCreatePrivate,\n}\n\nenum KeyEncoding {\n  kKeyEncodingPKCS1,\n  kKeyEncodingPKCS8,\n  kKeyEncodingSPKI,\n  kKeyEncodingSEC1,\n}\n\nconst encodingNames = {\n  [KeyEncoding.kKeyEncodingPKCS1]: 'pkcs1',\n  [KeyEncoding.kKeyEncodingPKCS8]: 'pkcs8',\n  [KeyEncoding.kKeyEncodingSPKI]: 'spki',\n  [KeyEncoding.kKeyEncodingSEC1]: 'sec1',\n};\n\nfunction option(name: string, objName: string | undefined) {\n  return objName === undefined\n    ? `options.${name}`\n    : `options.${objName}.${name}`;\n}\n\nfunction parseKeyFormat(\n  formatStr: string | undefined,\n  defaultFormat: KFormatType | undefined,\n  optionName?: string\n) {\n  if (formatStr === undefined && defaultFormat !== undefined)\n    return defaultFormat;\n  else if (formatStr === 'pem') return KFormatType.kKeyFormatPEM;\n  else if (formatStr === 'der') return KFormatType.kKeyFormatDER;\n  else if (formatStr === 'jwk') return KFormatType.kKeyFormatJWK;\n  throw new Error(`Invalid key format str: ${optionName}`);\n  // throw new ERR_INVALID_ARG_VALUE(optionName, formatStr);\n}\n\nfunction parseKeyType(\n  typeStr: string | undefined,\n  required: boolean,\n  keyType: string | undefined,\n  isPublic: boolean | undefined,\n  optionName: string\n) {\n  if (typeStr === undefined && !required) {\n    return undefined;\n  } else if (typeStr === 'pkcs1') {\n    if (keyType !== undefined && keyType !== 'rsa') {\n      throw new Error(\n        `Crypto incompatible key options: ${typeStr} can only be used for RSA keys`\n      );\n    }\n    return KeyEncoding.kKeyEncodingPKCS1;\n  } else if (typeStr === 'spki' && isPublic !== false) {\n    return KeyEncoding.kKeyEncodingSPKI;\n  } else if (typeStr === 'pkcs8' && isPublic !== true) {\n    return KeyEncoding.kKeyEncodingPKCS8;\n  } else if (typeStr === 'sec1' && isPublic !== true) {\n    if (keyType !== undefined && keyType !== 'ec') {\n      throw new Error(\n        `Incompatible key options ${typeStr} can only be used for EC keys`\n      );\n    }\n    return KeyEncoding.kKeyEncodingSEC1;\n  }\n\n  throw new Error(`Invalid option ${optionName} - ${typeStr}`);\n}\n\nfunction parseKeyFormatAndType(\n  enc: {\n    key: any;\n    type?: string;\n    encoding?: string;\n    format?: string;\n    cipher?: string;\n    passphrase?: string;\n  },\n  keyType: string | undefined,\n  isPublic: boolean | undefined,\n  objName: string | undefined\n) {\n  const { format: formatStr, type: typeStr } = enc;\n\n  const isInput = keyType === undefined;\n  const format = parseKeyFormat(\n    formatStr,\n    isInput ? KFormatType.kKeyFormatPEM : undefined,\n    option('format', objName)\n  );\n\n  const isRequired =\n    (!isInput || format === KFormatType.kKeyFormatDER) &&\n    format !== KFormatType.kKeyFormatJWK;\n\n  const type = parseKeyType(\n    typeStr,\n    isRequired,\n    keyType,\n    isPublic,\n    option('type', objName)\n  );\n  return { format, type };\n}\n\nfunction parseKeyEncoding(\n  enc: {\n    key: any;\n    type?: string;\n    encoding?: string;\n    format?: string;\n    cipher?: string;\n    passphrase?: string;\n  },\n  keyType: string | undefined,\n  isPublic: boolean | undefined,\n  objName?: string | undefined\n) {\n  // validateObject(enc, 'options');\n\n  const isInput = keyType === undefined;\n\n  const { format, type } = parseKeyFormatAndType(\n    enc,\n    keyType,\n    isPublic,\n    objName\n  );\n\n  let cipher, passphrase, encoding;\n  if (isPublic !== true) {\n    ({ cipher, passphrase, encoding } = enc);\n\n    if (!isInput) {\n      if (cipher != null) {\n        if (typeof cipher !== 'string')\n          throw new Error(\n            `Invalid argument ${option('cipher', objName)}: ${cipher}`\n          );\n        if (\n          format === KFormatType.kKeyFormatDER &&\n          (type === KeyEncoding.kKeyEncodingPKCS1 ||\n            type === KeyEncoding.kKeyEncodingSEC1)\n        ) {\n          throw new Error(\n            `Incompatible key options ${encodingNames[type]} does not support encryption`\n          );\n        }\n      } else if (passphrase !== undefined) {\n        throw new Error(\n          `invalid argument ${option('cipher', objName)}: ${cipher}`\n        );\n      }\n    }\n\n    if (\n      (isInput && passphrase !== undefined && !isStringOrBuffer(passphrase)) ||\n      (!isInput && cipher != null && !isStringOrBuffer(passphrase))\n    ) {\n      throw new Error(\n        `Invalid argument value ${option('passphrase', objName)}: ${passphrase}`\n      );\n    }\n  }\n\n  if (passphrase !== undefined)\n    passphrase = binaryLikeToArrayBuffer(passphrase, encoding);\n\n  return { format, type, cipher, passphrase };\n}\n\nfunction prepareAsymmetricKey(\n  key:\n    | BinaryLike\n    | { key: any; encoding?: string; format?: any; passphrase?: string },\n  ctx: KeyInputContext\n): {\n  format: KFormatType;\n  data: ArrayBuffer;\n  type?: any;\n  passphrase?: any;\n} {\n  // TODO(osp) check, KeyObject some node object\n  // if (isKeyObject(key)) {\n  //   // Best case: A key object, as simple as that.\n  //   return { data: getKeyObjectHandle(key, ctx) };\n  // } else\n  // if (isCryptoKey(key)) {\n  //   return { data: getKeyObjectHandle(key[kKeyObject], ctx) };\n  // } else\n  if (isStringOrBuffer(key)) {\n    // Expect PEM by default, mostly for backward compatibility.\n    return {\n      format: KFormatType.kKeyFormatPEM,\n      data: binaryLikeToArrayBuffer(key),\n    };\n  } else if (typeof key === 'object') {\n    const {\n      key: data,\n      encoding,\n      // format\n    } = key;\n    // // The 'key' property can be a KeyObject as well to allow specifying\n    // // additional options such as padding along with the key.\n    // if (isKeyObject(data)) return { data: getKeyObjectHandle(data, ctx) };\n    // else if (isCryptoKey(data))\n    //   return { data: getKeyObjectHandle(data[kKeyObject], ctx) };\n    // else if (isJwk(data) && format === 'jwk')\n    //   return { data: getKeyObjectHandleFromJwk(data, ctx), format: 'jwk' };\n    // Either PEM or DER using PKCS#1 or SPKI.\n    if (!isStringOrBuffer(data)) {\n      throw new Error(\n        'prepareAsymmetricKey: key is not a string or ArrayBuffer'\n      );\n    }\n\n    const isPublic =\n      ctx === KeyInputContext.kConsumePrivate ||\n      ctx === KeyInputContext.kCreatePrivate\n        ? false\n        : undefined;\n\n    return {\n      data: binaryLikeToArrayBuffer(data, encoding),\n      ...parseKeyEncoding(key, undefined, isPublic),\n    };\n  }\n\n  throw new Error('[prepareAsymetricKey] Invalid argument key: ${key}');\n}\n\n// TODO(osp) any here is a node KeyObject\nexport function preparePrivateKey(\n  key:\n    | BinaryLike\n    | {\n        key: any;\n        encoding?: string;\n        format?: any;\n        padding?: number;\n        passphrase?: string;\n      }\n) {\n  return prepareAsymmetricKey(key, KeyInputContext.kConsumePrivate);\n}\n\n// TODO(osp) any here is a node KeyObject\nexport function preparePublicOrPrivateKey(\n  key:\n    | BinaryLike\n    | { key: any; encoding?: string; format?: any; padding?: number }\n) {\n  return prepareAsymmetricKey(key, KeyInputContext.kConsumePublic);\n}\n\n// Parses the public key encoding based on an object. keyType must be undefined\n// when this is used to parse an input encoding and must be a valid key type if\n// used to parse an output encoding.\nexport function parsePublicKeyEncoding(\n  enc: {\n    key: any;\n    encoding?: string;\n    format?: string;\n    cipher?: string;\n    passphrase?: string;\n  },\n  keyType: string | undefined,\n  objName?: string\n) {\n  return parseKeyEncoding(enc, keyType, keyType ? true : undefined, objName);\n}\n\n// Parses the private key encoding based on an object. keyType must be undefined\n// when this is used to parse an input encoding and must be a valid key type if\n// used to parse an output encoding.\nexport function parsePrivateKeyEncoding(\n  enc: {\n    key: any;\n    encoding?: string;\n    format?: string;\n    cipher?: string;\n    passphrase?: string;\n  },\n  keyType: string | undefined,\n  objName?: string\n) {\n  return parseKeyEncoding(enc, keyType, false, objName);\n}\n"]}