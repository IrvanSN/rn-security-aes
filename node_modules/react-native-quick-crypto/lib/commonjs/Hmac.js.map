{"version":3,"sources":["Hmac.ts"],"names":["createInternalHmac","NativeQuickCrypto","createHmac","algorithm","key","options","Hmac","Stream","Transform","constructor","_options","keyAsString","undefined","internalHmac","update","data","inputEncoding","ArrayBuffer","buffer","Buffer","from","_transform","chunk","encoding","callback","_flush","push","digest","result","isFinalized","toString"],"mappings":";;;;;;;AACA;;AAEA;;AAMA;;AACA;;;;;;AAEA,MAAMA,kBAAkB,GAAGC,qCAAkBC,UAA7C;;AAEO,SAASA,UAAT,CACLC,SADK,EAELC,GAFK,EAGLC,OAHK,EAIL;AACA,SAAO,IAAIC,IAAJ,CAASH,SAAT,EAAoBC,GAApB,EAAyBC,OAAzB,CAAP;AACD;;AAED,MAAMC,IAAN,SAAmBC,0BAAOC,SAA1B,CAAoC;AAIlCC,EAAAA,WAAW,CACTN,SADS,EAETC,GAFS,EAGTM,QAHS,EAIT;AACA;;AADA;;AAAA,yCAN6B,KAM7B;;AAEA,QAAIC,WAAW,GAAG,oCAAwBP,GAAxB,CAAlB;;AAEA,QAAIO,WAAW,KAAKC,SAApB,EAA+B;AAC7B,YAAM,gBAAN;AACD;;AAED,SAAKC,YAAL,GAAoBb,kBAAkB,CACpCG,SADoC,EAEpCQ,WAFoC,CAAtC;AAID;AAED;AACF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AACEG,EAAAA,MAAM,CAACC,IAAD,EAA4BC,aAA5B,EAA4D;AAChE,QAAID,IAAI,YAAYE,WAApB,EAAiC;AAC/B,WAAKJ,YAAL,CAAkBC,MAAlB,CAAyBC,IAAzB;AACA,aAAO,IAAP;AACD;;AACD,QAAI,OAAOA,IAAP,KAAgB,QAApB,EAA8B;AAC5B,YAAMG,MAAM,GAAGC,0BAAOC,IAAP,CAAYL,IAAZ,EAAkBC,aAAlB,CAAf;;AACA,WAAKH,YAAL,CAAkBC,MAAlB,CAAyB,0BAAcI,MAAd,CAAzB;AACA,aAAO,IAAP;AACD;;AAED,SAAKL,YAAL,CAAkBC,MAAlB,CAAyB,oCAAwBC,IAAxB,CAAzB;AACA,WAAO,IAAP;AACD;;AAEDM,EAAAA,UAAU,CACRC,KADQ,EAERC,QAFQ,EAGRC,QAHQ,EAIR;AACA,SAAKV,MAAL,CAAYQ,KAAZ,EAAmBC,QAAnB;AACAC,IAAAA,QAAQ;AACT;;AAEDC,EAAAA,MAAM,CAACD,QAAD,EAAuB;AAC3B,SAAKE,IAAL,CAAU,KAAKC,MAAL,EAAV;AACAH,IAAAA,QAAQ;AACT;AAED;AACF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AAIEG,EAAAA,MAAM,CAACJ,QAAD,EAAkD;AACtD,UAAMK,MAAmB,GAAG,KAAKC,WAAL,GACxB,IAAIZ,WAAJ,CAAgB,CAAhB,CADwB,GAExB,KAAKJ,YAAL,CAAkBc,MAAlB,EAFJ;AAGA,SAAKE,WAAL,GAAmB,IAAnB;;AACA,QAAIN,QAAQ,IAAIA,QAAQ,KAAK,QAA7B,EAAuC;AACrC,aAAOJ,0BAAOC,IAAP,CAAYQ,MAAZ,EAAoBE,QAApB,CAA6BP,QAA7B,CAAP;AACD;;AACD,WAAOJ,0BAAOC,IAAP,CAAYQ,MAAZ,CAAP;AACD;;AAnFiC","sourcesContent":["/* eslint-disable no-dupe-class-members */\nimport { NativeQuickCrypto } from './NativeQuickCrypto/NativeQuickCrypto';\nimport type { InternalHmac } from './NativeQuickCrypto/hmac';\nimport {\n  Encoding,\n  toArrayBuffer,\n  BinaryLike,\n  binaryLikeToArrayBuffer,\n} from './Utils';\nimport Stream from 'stream-browserify';\nimport { Buffer } from '@craftzdog/react-native-buffer';\n\nconst createInternalHmac = NativeQuickCrypto.createHmac;\n\nexport function createHmac(\n  algorithm: string,\n  key: BinaryLike,\n  options?: Stream.TransformOptions\n) {\n  return new Hmac(algorithm, key, options);\n}\n\nclass Hmac extends Stream.Transform {\n  private internalHmac: InternalHmac;\n  private isFinalized: boolean = false;\n\n  constructor(\n    algorithm: string,\n    key: BinaryLike,\n    _options?: Stream.TransformOptions\n  ) {\n    super();\n    let keyAsString = binaryLikeToArrayBuffer(key);\n\n    if (keyAsString === undefined) {\n      throw 'Wrong key type';\n    }\n\n    this.internalHmac = createInternalHmac(\n      algorithm,\n      keyAsString as ArrayBuffer\n    );\n  }\n\n  /**\n   * Updates the `Hmac` content with the given `data`, the encoding of which\n   * is given in `inputEncoding`.\n   * If `encoding` is not provided, and the `data` is a string, an\n   * encoding of `'utf8'` is enforced. If `data` is a `Buffer`, `TypedArray`, or`DataView`, then `inputEncoding` is ignored.\n   *\n   * This can be called many times with new data as it is streamed.\n   * @since v0.1.94\n   * @param inputEncoding The `encoding` of the `data` string.\n   */\n  update(data: string | BinaryLike, inputEncoding?: Encoding): Hmac {\n    if (data instanceof ArrayBuffer) {\n      this.internalHmac.update(data);\n      return this;\n    }\n    if (typeof data === 'string') {\n      const buffer = Buffer.from(data, inputEncoding);\n      this.internalHmac.update(toArrayBuffer(buffer));\n      return this;\n    }\n\n    this.internalHmac.update(binaryLikeToArrayBuffer(data));\n    return this;\n  }\n\n  _transform(\n    chunk: string | BinaryLike,\n    encoding: Encoding,\n    callback: () => void\n  ) {\n    this.update(chunk, encoding);\n    callback();\n  }\n\n  _flush(callback: () => void) {\n    this.push(this.digest());\n    callback();\n  }\n\n  /**\n   * Calculates the HMAC digest of all of the data passed using `hmac.update()`.\n   * If `encoding` is\n   * provided a string is returned; otherwise a `Buffer` is returned;\n   *\n   * The `Hmac` object can not be used again after `hmac.digest()` has been\n   * called. Multiple calls to `hmac.digest()` will result in an error being thrown.\n   * @since v0.1.94\n   * @param encoding The `encoding` of the return value.\n   */\n  digest(): Buffer;\n  digest(encoding: 'buffer'): Buffer;\n  digest(encoding: Encoding): string;\n  digest(encoding?: Encoding | 'buffer'): string | Buffer {\n    const result: ArrayBuffer = this.isFinalized\n      ? new ArrayBuffer(0)\n      : this.internalHmac.digest();\n    this.isFinalized = true;\n    if (encoding && encoding !== 'buffer') {\n      return Buffer.from(result).toString(encoding);\n    }\n    return Buffer.from(result);\n  }\n}\n"]}